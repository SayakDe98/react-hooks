{"ast":null,"code":"var _jsxFileName = \"/home/lnv112/Documents/react-hooks-for-optimization/src/App.js\",\n  _s = $RefreshSig$();\n// import { useState } from 'react';\n// import './App.css';\n\n// function App() {\n//   const [number, setNumber] = useState(0);\n//   const [dark, setDark] = useState(false);\n//   const doubleNumber = slowFunction(number);\n//   const themeStyles = {\n//     backgroundColor: dark ? 'black' : 'white',\n//     color: dark ? 'white' : 'black'\n//   }\n\n//   return (\n//     <>\n//     <input type=\"number\" value={number} onChange={e => setNumber(parseInt(e.target.value))} />\n//     <button onClick={() => setDark(prevDark => !prevDark)}>Change Theme</button>\n//     <div style={themeStyles}>{doubleNumber}</div>\n//     </>\n//   );\n// }\n\n// function slowFunction(num) {\n//   console.log('Calling Slow Function');\n//   for(let i = 0; i < 1000000000; i++) {\n//     return num * 2;\n//   }\n// }\n\n// export default App;\n\n//For the above code the whole code above return is ran over and over again. \n// It is making our app slow. So we need to use a hook called useMemo. We will be caching our old number and it multiplied by 2. So we don't need to recalculate it again.\n//With the useMemo hook, we will be re running the slow function only when the number change as it is a dependency of the slow function\n//Now we will see the number change is slow but when we change theme it is fast\n//Also we don't want to use this hook every time where caching is not required because we are calling useMemo hook which takes time, we are storing / memoizing the value of the slowFunction which takes space. So it gives performance issues if we use the useMemo hook every where.\n\n// import { useMemo, useState } from 'react';\n// import './App.css';\n\n// function App() {\n//   const [number, setNumber] = useState(0);\n//   const [dark, setDark] = useState(false);\n//   const doubleNumber = useMemo(() => slowFunction(number), [number]);\n//   const themeStyles = {\n//     backgroundColor: dark ? 'black' : 'white',\n//     color: dark ? 'white' : 'black'\n//   }\n\n//   return (\n//     <>\n//     <input type=\"number\" value={number} onChange={e => setNumber(parseInt(e.target.value))} />\n//     <button onClick={() => setDark(prevDark => !prevDark)}>Change Theme</button>\n//     <div style={themeStyles}>{doubleNumber}</div>\n//     </>\n//   );\n// }\n\n// function slowFunction(num) {\n//   console.log('Calling Slow Function');\n//   for(let i = 0; i < 100000000; i++) {\n//     return num * 2;\n//   }\n// }\n\n// export default App;\n\n//Now let's talk about referential equality\n//Let's say there are two functions: \n//1) function sum(num) { return num * 3 };\n//2) function sum2(num) { return num * 3 };\n//The two functions are doing the same work but they are not equal.\n\n//Now let's run useEffect every time our themeStyles changes. We see that when we run change theme then also Theme Changed gets printed. This happens because of referential equality. Every time we run our function we get a new themeStyles object being created. This themeStyles object is not same as old themeStyles object. They have exact same value but they reference different places in memory.\n\n// import { useEffect, useMemo, useState } from \"react\";\n// import \"./App.css\";\n\n// function App() {\n//   const [number, setNumber] = useState(0);\n//   const [dark, setDark] = useState(false);\n//   const doubleNumber = useMemo(() => slowFunction(number), [number]);\n//   const themeStyles = {\n//     backgroundColor: dark ? \"black\" : \"white\",\n//     color: dark ? \"white\" : \"black\",\n//   };\n\n//   useEffect(() => console.log(\"Theme Changed\"), [themeStyles]);\n\n//   return (\n//     <>\n//       <input\n//         type=\"number\"\n//         value={number}\n//         onChange={(e) => setNumber(parseInt(e.target.value))}\n//       />\n//       <button onClick={() => setDark((prevDark) => !prevDark)}>\n//         Change Theme\n//       </button>\n//       <div style={themeStyles}>{doubleNumber}</div>\n//     </>\n//   );\n// }\n\n// function slowFunction(num) {\n//   console.log(\"Calling Slow Function\");\n//   for (let i = 0; i < 100000000; i++) {\n//     return num * 2;\n//   }\n// }\n\n// export default App;\n\n//To get rid of this issue we will wrap themeStyles with useMemo hook as well.\n\nimport { useEffect, useMemo, useState } from \"react\";\nimport \"./App.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nfunction App() {\n  _s();\n  const [number, setNumber] = useState(0);\n  const [dark, setDark] = useState(false);\n  const doubleNumber = useMemo(() => slowFunction(number), [number]);\n  const themeStyles = useMemo(() => {\n    return {\n      backgroundColor: dark ? \"black\" : \"white\",\n      color: dark ? \"white\" : \"black\"\n    };\n  }, []);\n  useEffect(() => console.log(\"Theme Changed\"), [themeStyles]);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"input\", {\n      type: \"number\",\n      value: number,\n      onChange: e => setNumber(parseInt(e.target.value))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 134,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => setDark(prevDark => !prevDark),\n      children: \"Change Theme\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 139,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: themeStyles,\n      children: doubleNumber\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 142,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n}\n_s(App, \"g9r3xjpKNZKud+C8s8INoFAV5ek=\");\n_c = App;\nfunction slowFunction(num) {\n  console.log(\"Calling Slow Function\");\n  for (let i = 0; i < 100000000; i++) {\n    return num * 2;\n  }\n}\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["useEffect","useMemo","useState","jsxDEV","_jsxDEV","Fragment","_Fragment","App","_s","number","setNumber","dark","setDark","doubleNumber","slowFunction","themeStyles","backgroundColor","color","console","log","children","type","value","onChange","e","parseInt","target","fileName","_jsxFileName","lineNumber","columnNumber","onClick","prevDark","style","_c","num","i","$RefreshReg$"],"sources":["/home/lnv112/Documents/react-hooks-for-optimization/src/App.js"],"sourcesContent":["// import { useState } from 'react';\n// import './App.css';\n\n// function App() {\n//   const [number, setNumber] = useState(0);\n//   const [dark, setDark] = useState(false);\n//   const doubleNumber = slowFunction(number);\n//   const themeStyles = {\n//     backgroundColor: dark ? 'black' : 'white',\n//     color: dark ? 'white' : 'black'\n//   }\n\n//   return (\n//     <>\n//     <input type=\"number\" value={number} onChange={e => setNumber(parseInt(e.target.value))} />\n//     <button onClick={() => setDark(prevDark => !prevDark)}>Change Theme</button>\n//     <div style={themeStyles}>{doubleNumber}</div>\n//     </>\n//   );\n// }\n\n// function slowFunction(num) {\n//   console.log('Calling Slow Function');\n//   for(let i = 0; i < 1000000000; i++) {\n//     return num * 2;\n//   }\n// }\n\n// export default App;\n\n//For the above code the whole code above return is ran over and over again. \n// It is making our app slow. So we need to use a hook called useMemo. We will be caching our old number and it multiplied by 2. So we don't need to recalculate it again.\n//With the useMemo hook, we will be re running the slow function only when the number change as it is a dependency of the slow function\n//Now we will see the number change is slow but when we change theme it is fast\n//Also we don't want to use this hook every time where caching is not required because we are calling useMemo hook which takes time, we are storing / memoizing the value of the slowFunction which takes space. So it gives performance issues if we use the useMemo hook every where.\n\n// import { useMemo, useState } from 'react';\n// import './App.css';\n\n// function App() {\n//   const [number, setNumber] = useState(0);\n//   const [dark, setDark] = useState(false);\n//   const doubleNumber = useMemo(() => slowFunction(number), [number]);\n//   const themeStyles = {\n//     backgroundColor: dark ? 'black' : 'white',\n//     color: dark ? 'white' : 'black'\n//   }\n\n//   return (\n//     <>\n//     <input type=\"number\" value={number} onChange={e => setNumber(parseInt(e.target.value))} />\n//     <button onClick={() => setDark(prevDark => !prevDark)}>Change Theme</button>\n//     <div style={themeStyles}>{doubleNumber}</div>\n//     </>\n//   );\n// }\n\n// function slowFunction(num) {\n//   console.log('Calling Slow Function');\n//   for(let i = 0; i < 100000000; i++) {\n//     return num * 2;\n//   }\n// }\n\n// export default App;\n\n\n//Now let's talk about referential equality\n//Let's say there are two functions: \n//1) function sum(num) { return num * 3 };\n//2) function sum2(num) { return num * 3 };\n//The two functions are doing the same work but they are not equal.\n\n//Now let's run useEffect every time our themeStyles changes. We see that when we run change theme then also Theme Changed gets printed. This happens because of referential equality. Every time we run our function we get a new themeStyles object being created. This themeStyles object is not same as old themeStyles object. They have exact same value but they reference different places in memory.\n\n// import { useEffect, useMemo, useState } from \"react\";\n// import \"./App.css\";\n\n// function App() {\n//   const [number, setNumber] = useState(0);\n//   const [dark, setDark] = useState(false);\n//   const doubleNumber = useMemo(() => slowFunction(number), [number]);\n//   const themeStyles = {\n//     backgroundColor: dark ? \"black\" : \"white\",\n//     color: dark ? \"white\" : \"black\",\n//   };\n\n//   useEffect(() => console.log(\"Theme Changed\"), [themeStyles]);\n\n//   return (\n//     <>\n//       <input\n//         type=\"number\"\n//         value={number}\n//         onChange={(e) => setNumber(parseInt(e.target.value))}\n//       />\n//       <button onClick={() => setDark((prevDark) => !prevDark)}>\n//         Change Theme\n//       </button>\n//       <div style={themeStyles}>{doubleNumber}</div>\n//     </>\n//   );\n// }\n\n// function slowFunction(num) {\n//   console.log(\"Calling Slow Function\");\n//   for (let i = 0; i < 100000000; i++) {\n//     return num * 2;\n//   }\n// }\n\n// export default App;\n\n//To get rid of this issue we will wrap themeStyles with useMemo hook as well.\n\nimport { useEffect, useMemo, useState } from \"react\";\nimport \"./App.css\";\n\nfunction App() {\n  const [number, setNumber] = useState(0);\n  const [dark, setDark] = useState(false);\n  const doubleNumber = useMemo(() => slowFunction(number), [number]);\n  const themeStyles = useMemo(() => {\n    return {\n    backgroundColor: dark ? \"black\" : \"white\",\n    color: dark ? \"white\" : \"black\",\n  }\n},[]);\n\n  useEffect(() => console.log(\"Theme Changed\"), [themeStyles]);\n\n  return (\n    <>\n      <input\n        type=\"number\"\n        value={number}\n        onChange={(e) => setNumber(parseInt(e.target.value))}\n      />\n      <button onClick={() => setDark((prevDark) => !prevDark)}>\n        Change Theme\n      </button>\n      <div style={themeStyles}>{doubleNumber}</div>\n    </>\n  );\n}\n\nfunction slowFunction(num) {\n  console.log(\"Calling Slow Function\");\n  for (let i = 0; i < 100000000; i++) {\n    return num * 2;\n  }\n}\n\nexport default App;\n"],"mappings":";;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,SAASA,SAAS,EAAEC,OAAO,EAAEC,QAAQ,QAAQ,OAAO;AACpD,OAAO,WAAW;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAAA,SAAAC,QAAA,IAAAC,SAAA;AAEnB,SAASC,GAAGA,CAAA,EAAG;EAAAC,EAAA;EACb,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGR,QAAQ,CAAC,CAAC,CAAC;EACvC,MAAM,CAACS,IAAI,EAAEC,OAAO,CAAC,GAAGV,QAAQ,CAAC,KAAK,CAAC;EACvC,MAAMW,YAAY,GAAGZ,OAAO,CAAC,MAAMa,YAAY,CAACL,MAAM,CAAC,EAAE,CAACA,MAAM,CAAC,CAAC;EAClE,MAAMM,WAAW,GAAGd,OAAO,CAAC,MAAM;IAChC,OAAO;MACPe,eAAe,EAAEL,IAAI,GAAG,OAAO,GAAG,OAAO;MACzCM,KAAK,EAAEN,IAAI,GAAG,OAAO,GAAG;IAC1B,CAAC;EACH,CAAC,EAAC,EAAE,CAAC;EAEHX,SAAS,CAAC,MAAMkB,OAAO,CAACC,GAAG,CAAC,eAAe,CAAC,EAAE,CAACJ,WAAW,CAAC,CAAC;EAE5D,oBACEX,OAAA,CAAAE,SAAA;IAAAc,QAAA,gBACEhB,OAAA;MACEiB,IAAI,EAAC,QAAQ;MACbC,KAAK,EAAEb,MAAO;MACdc,QAAQ,EAAGC,CAAC,IAAKd,SAAS,CAACe,QAAQ,CAACD,CAAC,CAACE,MAAM,CAACJ,KAAK,CAAC;IAAE;MAAAK,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACtD,CAAC,eACF1B,OAAA;MAAQ2B,OAAO,EAAEA,CAAA,KAAMnB,OAAO,CAAEoB,QAAQ,IAAK,CAACA,QAAQ,CAAE;MAAAZ,QAAA,EAAC;IAEzD;MAAAO,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAQ,CAAC,eACT1B,OAAA;MAAK6B,KAAK,EAAElB,WAAY;MAAAK,QAAA,EAAEP;IAAY;MAAAc,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAM,CAAC;EAAA,eAC7C,CAAC;AAEP;AAACtB,EAAA,CA1BQD,GAAG;AAAA2B,EAAA,GAAH3B,GAAG;AA4BZ,SAASO,YAAYA,CAACqB,GAAG,EAAE;EACzBjB,OAAO,CAACC,GAAG,CAAC,uBAAuB,CAAC;EACpC,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,SAAS,EAAEA,CAAC,EAAE,EAAE;IAClC,OAAOD,GAAG,GAAG,CAAC;EAChB;AACF;AAEA,eAAe5B,GAAG;AAAC,IAAA2B,EAAA;AAAAG,YAAA,CAAAH,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}